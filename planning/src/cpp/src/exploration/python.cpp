#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <pybind11/stl.h>

#include "exploration/astar.h"
#include "safe_array.h"

PYBIND11_MODULE(_exploration_cpp, m) {
  std::string functions;
  functions += "c_check_for_collision(pybind11::safe_array<int, 1> position,\n"
               "                      pybind11::safe_array<uint8_t, 2> occupancy_map,\n"
               "                      pybind11::safe_array<bool, 2> footprint_mask,\n"
               "                      pybind11::safe_array<int, 2> outline_coords,\n"
               "                      pybind11::safe_array<uint8_t, 1> obstacle_values)\n\n";
  functions += "c_astar(pybind11::safe_array<int, 1> start,\n"
               "        pybind11::safe_array<int, 1> goal,\n"
               "        pybind11::safe_array<uint8_t, 2> occupancy_map,\n"
               "        pybind11::safe_array<uint8_t, 1> obstacle_values,\n"
               "        float delta,\n"
               "        float epsilon,\n"
               "        int planning_scale,\n"
               "        bool allow_diagonal)\n\n";
  functions += "c_oriented_astar(pybind11::safe_array<int, 1> start,\n"
               "                 pybind11::safe_array<int, 1> goal,\n"
               "                 pybind11::safe_array<uint8_t, 2> occupancy_map,\n"
               "                 std::vector<pybind11::safe_array_mut<bool, 2> > footprint_masks,\n"
               "                 pybind11::safe_array<float, 1> mask_angles,\n"
               "                 std::vector<pybind11::safe_array_mut<int, 2> > outline_coords,\n"
               "                 pybind11::safe_array<uint8_t, 1> obstacle_values,\n"
               "                 const float delta,\n"
               "                 const float epsilon,\n"
               "                 const int planning_scale,\n"
               "                 const bool allow_diagonal)\n\n";
  functions += "c_get_astar_angles()\n\n";

  m.doc() = "Python bindings for the bc_exploration c++ code\n"
            "To have more documentation call the __doc__ method of the function\n\n"
            "Available functions:\n\n" + functions;

  m.def("c_check_for_collision", &check_for_collision, "Collision checking for custom footprints.                                                                                 \n"
                                                       "                                                                                                                          \n"
                                                       ":param position: 1x2 array with robot coordinate [row, column]                                                            \n"
                                                       ":param occupancy_map: 1xN*M array of flattened occupancy map                                                              \n"
                                                       ":param map_shape: 1x2 array with (N, M), the shape of the occupancy map                                                   \n"
                                                       ":param footprint_mask: (array(N*N)[int]) mask of the footprint rotated at the corresponding angle                         \n"
                                                       "                       needed for checking, i.e state[2]. N is 2 * mask_radius + 1,                                       \n"
                                                       "                       the values are -1 for not footprint, 0 for footprint. (note the (N,N) mask is flattened)           \n"
                                                       ":param mask_radius: (int) (footprint_mask.shape[0] - 1) / 2 the radius of the mask in pixels                              \n"
                                                       ":param outline_coords: (array(N*2)[int]) the coordinates that define the outline of the footprint. N is the number        \n"
                                                       "                       of points that define the outline of the footprint. (it is a (N,2) array but flattened)            \n"
                                                       ":param num_coords: number of coordinates in that define the outline of the footprint. i.e N from the description          \n"
                                                       "                   of outline_coords                                                                                      \n"
                                                       ":param obstacle_values: (array(N)[uint8]) an array containing values that the collision checker should deem as an obstacle\n"
                                                       "                        i.e [127, 0]                                                                                      \n"
                                                       ":param num_obstacle values: the number of obstacle values given in the obstacle_values array.                             \n"
                                                       "                                                                                                                          \n"
                                                       ":return: (bool) whether there is a collision or not                                                                       \n");
  m.def("c_astar", &astar, "A* algorithm                                                                                                         \n"
                           "                                                                                                                     \n"
                           ":param start array(2)[int32]: start coordinate [row, column]                                                         \n"
                           ":param goal array(2)[int32]: goal coordinate [row, column]                                                           \n"
                           ":param occupancy_map array(N, M)[uint8]: 2d occupancy map                                                            \n"
                           ":param obstacle_values array(N)[uint8]: values in the occupancy map we consider to be obstacles                      \n"
                           ":param delta float: distance (in pixels) of which we define around the goal coordinate, to consider as the goal      \n"
                           "                    if it is 0, we look to plan exactly to the goal coord, if its > 0 then we define the goal region \n"
                           "                    to be that many pixels bigger                                                                    \n"
                           ":param epsilon float: weighting for the heuristic in the A* algorithm                                                \n"
                           ":param planning_scale int: value > 1, to plan on a lower resolution than the original occupancy map resolution,      \n"
                           "                           this value is round_int(desired resolution / original resolution)                         \n"
                           ":param allow_diagonal bool: whether to allow diagonal movements                                                      \n"
                           ":return Tuple[bool, array(N, 2)[int32]]: is_successful - whether the goal pose was reached,                          \n"
                           "                                         path_px - array of coordinates for the most promising path if not successful\n"
                           "                                                   otherwise it is the path to the goal.                             \n"
                           "                                                                                                                     \n");
  m.def("c_oriented_astar", &oriented_astar, "Oriented A* algorithm, does not plan on angular space, rather has assigned angles for each movement direction.        \n"
                                             "                                                                                                                      \n"
                                             ":param start array(2)[float32]: start coordinate [row, column]                                                        \n"
                                             ":param goal array(2)[float32]: goal coordinate [row, column]                                                          \n"
                                             ":param occupancy_map array(N, M)[uint8]: 2d occupancy map                                                             \n"
                                             ":param footprint_masks List[array(U, U)]: U is the size of a UxU mask for checking footprint collision,               \n"
                                             "                                          where U must be odd, such that U / 2 + 1 is the center pixel,               \n"
                                             "                                          the mask is true for footprint and false for not footprint,                 \n"
                                             "                                          which is centered among the center pixel in the mask.                       \n"
                                             "                                          Each mask in the list corresponds to a footprint mask for each angle        \n"
                                             "                                          defined in mask_angles.                                                     \n"
                                             ":param mask_angles array(8)[float32]: 1x8 array of these angles (in order)                                            \n"
                                             "                                      [-pi, -3pi/4, -pi/2, -pi/4, 0, pi/4, pi/2, 3pi/4]                               \n"
                                             "                                      can use the get_astar_angles() function to get these angles.                    \n"
                                             ":param outline_coords array(N, 2)[int32]: coordinates corresponding to the outline of the footprint in ego coordinates\n"
                                             "                                          used for quick checking of out of bounds / collisions                       \n"
                                             ":param obstacle_values array(N)[uint8]: values in the occupancy map we consider to be obstacles                       \n"
                                             ":param delta float: distance (in pixels) of which we define around the goal coordinate, to consider as the goal       \n"
                                             "                    if it is 0, we look to plan exactly to the goal coord, if its > 0 then we define the goal region  \n"
                                             "                    to be that many pixels bigger                                                                     \n"
                                             ":param epsilon float: weighting for the heuristic in the A* algorithm                                                 \n"
                                             ":param planning_scale int: value > 1, to plan on a lower resolution than the original occupancy map resolution,       \n"
                                             "                      this value is round_int(desired resolution / original resolution)                               \n"
                                             ":param allow_diagonal bool: whether to allow diagonal movements                                                       \n"
                                             ":return Tuple[bool, array(N, 2)[int32]]: is_successful - whether the goal pose was reached,                           \n"
                                             "                                         path_px - array of coordinates for the most promising path if not successful \n"
                                             "                                                   otherwise it is the path to the goal.                              \n");
  m.def("c_get_astar_angles", &get_astar_angles, "gets angles used for astar                        \n"
                                                 "these angles correspond to the x,y world converted\n"
                                                 "angles of moving in the corresponding             \n"
                                                 "children direction in the astar algorithm         \n"
                                                 "see astar assignment of children.                 \n");
}
